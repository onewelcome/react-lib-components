import { Canvas, Story, Title, Subtitle, ArgTypes, Meta } from "@storybook/blocks";
import * as RadioStories from "./Radio.stories.tsx";

<Meta of={RadioStories} />
<Title />
<Subtitle />

The `Radio` component is a native HTML `input` element. And just like the native elements, it should be linked to a `form`. This can be done by either nesting the `Radio` component inside of a `Form` component, or by linking to a `form` element by using the appropriate `form` attribute. As is default with `<input type="radio"/>` HTMLElements, `Radio`s are grouped together through the `name` attribute.

For proper accessibility, it is recommended to nest the `Radio` component inside a `Fieldset` component, so it has a `legend` element that tells the end-user what they represent. [The `RadioWrapper` component already does this for you.](/docs/stories-form-wrapper-radiowrapper--radio-wrapper)

Each individual radio button can have its own `helperText` and `errorMessage`. By default, the `helperText` will be shown **if** this prop is filled in. As soon as the `error` prop is set to `true`, the `errorMessage` will be shown.

## Composability

You can use any component you want as a `Radio` label - simply pass it as a `children` prop. Just make sure that the styling of the component matches our guidelines - `Radio` doesn't override styles of its `children`.

## Custom helper text and error message

You can compose both helper text and error message out of any components you'd like. Keep in mind you will need to handle the proper styling of those custom elements. All you need to do is to pass the `children` to `helperProps` for custom `helperText`
or `error` set to `true` along with `children` in `errorMessageProps` for custom error message.

# Examples

A code example of how you could use the `Radio` component with state:

```jsx
const ExampleComponent = () => {
  const [radioValue, setRadioValue] = useState("option1");

  return (
    <Fieldset legend="Radio button group">
      <Radio
        name="example-name"
        value="option1"
        onChange={event => setRadioValue(event.target.value)}
        checked={radioValue === "option1"}
      >
        Option 1
      </Radio>
      <Radio
        name="example-name"
        value="option2"
        onChange={event => setRadioValue(event.target.value)}
        checked={radioValue === "option2"}
      >
        Option 2
      </Radio>
      <Radio
        name="example-name"
        value="option3"
        onChange={event => setRadioValue(event.target.value)}
        checked={radioValue === "option3"}
      >
        Option 3
      </Radio>
      <Radio
        name="example-name"
        value="option4"
        onChange={event => setRadioValue(event.target.value)}
        checked={radioValue === "option4"}
      >
        Option 4
      </Radio>
    </Fieldset>
  );
};
```

A code example of a `Radio` with composed elements:

```jsx
const ExampleComponent = () => {
  const [radioValue, setRadioValue] = useState("option1");

  const helperTextProps = {
    children: (
      <div>
        Helper text with <a href="/">link</a>
      </div>
    )
  };

  return(
    <Radio
      {...args}
      helperText="Example helpertext"
      helperProps={helperTextProps}
      onChange={event => setRadioValue(event.target.value)}
      value="bold"
      checked={radioValue === "bold"}
    >
      <>
        Label with a <b>bold part</b>{" "}
      </>
    </Radio>
  )
```

<Canvas>
  <Story of={RadioStories.Radio} />
</Canvas>

# Props

<ArgTypes />
